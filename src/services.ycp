/**
 * File:
 *   services.ycp
 *
 * Module:
 *   Runlevel Editor
 *
 * Summary:
 *   Service maintanance
 *
 * Authors:
 *   Petr Blahos <pblahos@suse.cz>
 *
 * $Id$
 *
 * This include file contains functions for reading runlevels, services,
 * starting/stopping services ...
 */

{
    /**
     * Get current runlevel into global current_runlevel.
     */
    global define readCurrentRunlevel () ``{
        map out = SCR (`Execute (.target.bash_output, "/sbin/runlevel"));
        list l = splitstring (lookup (out, "stdout", ""), " \t\n");
        current_runlevel = ((size (l) < 2) ? "?" : select (l, 1));
    }

    /**
     * Get default runlevel from /etc/inittab
     */
    global define readDefaultRunlevel () ``{
        map out = SCR (`Execute (
            .target.bash_output,
            "/bin/cat /etc/inittab | /bin/grep 'id:.:initdefault:' | /bin/sed -e s/id://g -e s/:initdefault://g"));
        default_runlevel = sformat ("%1", tointeger (lookup (out, "stdout", "5")));
        default_runlevel_orig = default_runlevel;
    }

    /**
     * Writes default runlevel into /etc/inittab.
     * @param new_default New default runlevel.
     * @return integer 0 on success, -1 otherwise.
     */
    global define saveDefaultRunlevel (string new_default) ``{
        string tmp = SCR (`Read (.target.tmpdir)) + "/inittab";
        if (0 == SCR (`Execute (
            .target.bash,
            sformat ("/usr/bin/sed s/^id:.:initdefault:/id:%1:initdefault:/g /etc/inittab > %2", new_default, tmp)
            )))
            {
                SCR (`Execute (.target.bash, sformat ("cp %1 /etc/inittab; chmod 0644 %1; chown root:root %1", tmp)));
                return 0;
            }
        return -1;
    }

    /**
     * Runs init script.
     * @param script script to run
     * @param action argument to script
     * @return map map from .target.bash_output
     */
    global define runInitScript (string script, string action) ``{
        return SCR (`Execute (.target.bash_output, sformat ("TERM=raw /etc/init.d/%1 %2", script, action)));
    }

    /**
     * Runs service status and returns result.
     * @param service service name
     * @return string exit status
     */
    global define serviceStatus (string service) ``{
        integer ret = SCR (`Execute (.target.bash, sformat ("TERM=raw /etc/init.d/%1 status", service)));
        return sformat ("%1", ret);
    }

    /**
     * Get scripts info via agent. <br>
     * .init.scripts.runlevels returns map in format we need:
     *   $[ "servicename" : $[ ...], ...]. <br>
     * .init.scripts.comments returns map:
     * $[ "xS" : [ list of services ], "xK" : [ list of services ] ],
     * where x is runlevel name and S means start, K means kill.
     * So each tuple means that in runlevel x there is list of services
     * that are Started/Killed. This must be patched in services map<br>
     * Also START_ variables presence is patched into services. 
     */
    global define getScripts () ``{
        map details = SCR (`Read (.init.scripts.runlevels));
        services = SCR (`Read (.init.scripts.comments));
        services = mapmap (`k, `v, services, ``{
            if (haskey (start_variables_all, k))
                {
                    string start_val = SCR (`Read (add (.rc.system, lookup (start_variables_all, k))));
                    v = add (v, "START", "yes" == start_val ? true : false);
                }
            else
                {
                    v = add (v, "START", true);
                }
            service_list = add (service_list, k);
            list start = [];
            list stop = [];
            foreach (`i, runlevels, ``{
                if (contains (lookup (details, i + "S", []), k))
                    {
                        start = add (start, i);
                    }
                /* we do not use this info !!!
                if (contains (lookup (details, i + "K", []), k))
                    {
                        stop = add (stop, i);
                    }
                */
            });
            return [ k, add (add (v, "start", start), "stop", stop) ];
        });
    }

    /**
     * Reads directories /etc/init.d/rc?.d.
     * Changes global runlevels.
     */
    global define readRunlevelList () ``{
        map out = SCR (`Execute (.target.bash_output,"/usr/bin/awk '/^[^#]..*\\/etc\\/init\\.d\\/rc / { print $2 }' /etc/inittab"));
        if (0 != lookup (out, "exit"))
            {
                out = add (out, "stdout", "S\n0\n1\n2\n3\n4\n5\n6\n");
            }
        runlevels = filter (`j, splitstring (lookup (out, "stdout", ""), "\n"), ``{
            return j != "";
        });
        integer id = 2;
        foreach (`i, runlevels, ``{
            runlevel2tableindex = add (runlevel2tableindex, i, id);
            id = id + 1;
        });
    }

    /**
     * Save changed services into proper runlevels.
     */
    global define saveServices () ``{
        foreach (`k, `v, services, ``{
            if (lookup (v, "dirty", false))
                {
                    // save!
                    boolean disabled = isDisabled (v); //cache
                    string commandline = sformat ("/sbin/insserv %1,start=", k);
                    string add_comma = "";
                    list start = disabled ? [] : lookup (v, "start", []);
                    if (contains (lookup (v, "defstart"), "B"))
                        {
                            start = union (start, [ "B" ]);
                        }
                    foreach (`i, start, ``{
                        commandline = commandline + add_comma + i;
                        add_comma = ",";
                    });
                    y2milestone ("%1 ===> Running %2", k, commandline);
                    SCR (`Execute (.target.bash, commandline));
                    if (!disabled && haskey (start_variables_all, k))
                        { // set its START variable
                            SCR (`Write (add (.rc.system, lookup (start_variables_all, k)), "yes"));
                            y2milestone ("%1 ===> Settings START_ variable %2 to yes", k, lookup (start_variables_all, k));
                        }
                }
        });
    }

    /**
     * Is service disabled? Check "disabled" key which reflects whether service is disabled by some START_-like variable.
     * Otherwise it checks if it is disabled by unchecking all checkboxes...
     * @param service service to check
     * @return boolean true if service is disabled
     */
    global define isDisabled (map service) ``{
        if (!lookup (service, "START", true))
            {
                return true;
            }
        if (0 == size (lookup (service, "start", [])) && lookup (service, "start") != lookup (service, "defstart"))
            {
                return true;
            }
        return false;
    }

    /**
     * Are services dirty (changed)?
     * @return boolean true if services are dirty.
     */
    global define dirtyServices () ``{
        boolean dirty = false;
        foreach (`k, `v, services, ``{
            if (dirty)
                {
                    return ;
                }
            if (lookup (v, "dirty", false))
                {
                    dirty = true;
                }
        });
        return dirty;
    }
}
