/**
 * File:
 *   services.ycp
 *
 * Module:
 *   Runlevel Editor
 *
 * Summary:
 *   Service maintanance
 *
 * Authors:
 *   Petr Blahos <pblahos@suse.cz>
 *
 * $Id$
 *
 * This include file contains functions for reading runlevels, services,
 * starting/stopping services ...
 */

{
    /**
     * Get current runlevel into global current_runlevel.
     */
    global define readCurrentRunlevel () ``{
	current_runlevel = SCR::Read (.init.scripts.current_runlevel);
    }

    /**
     * Get default runlevel from /etc/inittab
     */
    global define readDefaultRunlevel () ``{
	default_runlevel = SCR::Read (.init.scripts.default_runlevel);
	default_runlevel_orig = default_runlevel;
    }

    /**
     * Writes default runlevel into /etc/inittab.
     * @param new_default New default runlevel.
     * @return integer 0 for success, -1 otherwise
     */
    global define saveDefaultRunlevel (string new_default) ``{
	return SCR::Write (.init.scripts.default_runlevel, new_default);
    }

    /**
     * Runs init script.
     * @param script script to run
     * @param action argument to script
     * @return map map from .target.bash_output
     */
    global define runInitScript (string script, string action) ``{
	return SCR::Execute (.target.bash_output, sformat ("TERM=raw /etc/init.d/%1 %2", script, action));
    }

    /**
     * Runs service status and returns result.
     * @param service service name
     * @return string exit status
     */
    global define serviceStatus (string service) ``{
	integer ret = SCR::Execute (.target.bash, sformat ("TERM=raw /etc/init.d/%1 status", service));
	return sformat ("%1", ret);
    }

    /**
     * Get scripts info via agent. <br>
     * .init.scripts.runlevels returns map in format we need:
     *   $[ "servicename" : $[ ...], ...]. <br>
     * .init.scripts.comments returns map:
     * $[ "xS" : [ list of services ], "xK" : [ list of services ] ],
     * where x is runlevel name and S means start, K means kill.
     * So each tuple means that in runlevel x there is list of services
     * that are Started/Killed. This must be patched in services map<br>
     * Also START_ variables presence is patched into services.
     */
    global define getScripts () ``{
	map details = SCR::Read (.init.scripts.runlevels);
	services = SCR::Read (.init.scripts.comments);
	services = mapmap (`k, `v, services, ``{
	    // play tennis
	    map second_service = lookup (details, k, $[]);
	    if (haskey (start_variables_all, k))
		{
		    string start_val = SCR::Read (add (.rc.system, lookup (start_variables_all, k)));
		    v = add (v, "START", "yes" == start_val ? true : false);
		}
	    else
		{
		    v = add (v, "START", true);
		}
	    service_list = add (service_list, k);
	    v = add (v, "start", lookup (second_service, "start", []));
	    v = add (v, "stop" , lookup (second_service, "stop",  []));
	    return [ k, v ];
	});
    }

    /**
     * Reads directories /etc/init.d/rc?.d.
     * Changes global runlevels.
     */
    global define readRunlevelList () ``{
	runlevels= SCR::Read (.init.scripts.runlevel_list);
	if (0 == size (runlevels))
	    {
		runlevels = ["0", "1", "2", "3", "5", "6", "S", ];
	    }
	integer id = 2;
	foreach (`i, runlevels, ``{
	    runlevel2tableindex = add (runlevel2tableindex, i, id);
	    id = id + 1;
	});
    }

    /**
     * Save changed services into proper runlevels.
     */
    global define saveServices () ``{
	foreach (`k, `v, services, ``{
	    if (lookup (v, "dirty", false))
		{
		    // save!
		    boolean disabled = isDisabled (v); //cache
		    string add_comma = "";
		    list start = lookup (v, "start", []);
		    if (disabled)
			{
			    start = haskey (start_variables_all, k) ? lookup (v, "defstart", []) : [];
			}
		    if (contains (lookup (v, "defstart", []), "B"))
			{
			    start = union (start, [ "B" ]);
			}
		    string commandline = "";
		    if (size (start)>0)
			{
			    commandline = sformat ("/sbin/insserv %1,start=", k);
			    foreach (`i, start, ``{
				commandline = commandline + add_comma + i;
				add_comma = ",";
			    });
			}
		    else
			{
			    commandline = sformat ("/sbin/insserv -r %1", k);
			}
		    y2milestone ("%1 ===> Running %2", k, commandline);
		    SCR::Execute (.target.bash, commandline);
		    if (haskey (start_variables_all, k))
			{ // set its START variable
			    SCR::Write (add (.rc.system, lookup (start_variables_all, k)), disabled ? "no" : "yes");
			    y2milestone ("%1 ===> Settings START_ variable %2 to yes", k, lookup (start_variables_all, k));
			}
		}
	});
    }

    /**
     * Is service disabled? Check "disabled" key which reflects whether service is disabled by some START_-like variable.
     * Otherwise it checks if it is disabled by unchecking all checkboxes...
     * @param service service to check
     * @return boolean true if service is disabled
     */
    global define isDisabled (map service) ``{
	if (!lookup (service, "START", true))
	    {
		return true;
	    }
	if (0 == size (lookup (service, "start", [])) && lookup (service, "start") != lookup (service, "defstart"))
	    {
		return true;
	    }
	return false;
    }

    /**
     * Are services dirty (changed)?
     * @return boolean true if services are dirty.
     */
    global define dirtyServices () ``{
	boolean dirty = false;
	foreach (`k, `v, services, ``{
	    if (dirty)
		{
		    return ;
		}
	    if (lookup (v, "dirty", false))
		{
		    dirty = true;
		}
	});
	return dirty;
    }
}
