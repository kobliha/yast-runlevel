/**
 * File:
 *   Runlevel.ycp
 *
 * Package:
 *   Runlevel Editor
 *
 * Summary:
 *   Exported functionality
 *
 * Authors:
 *   Petr Blahos <pblahos@suse.cz>
 *
 * $Id$
 *
 * Function exported by runlevel editor to other modules.
 * FIXME: check the situation about boot.* init scripts and
 * runlevel binary
 */

{
    module "Runlevel";
    textdomain "runlevel";
    import "Progress";

    /**
     * One service is described by such map: <pre>
      "servicename" : $[
	"defstart" : [ "2", "3", "5", ], // Default-Start comment
	"defstop"  : [ "0", "1", "6", ], // Default-Stop  comment

	"reqstart" : [ "$network", "portmap" ], // Required-Start comment
	"reqstop"  : [ "$network", "portmap" ], // Required-Stop  comment

	"description" : "text...",       // Description comment

	"start" : [ "3", "5", ], // which runlevels service is really started/stopped in
	"stop"  : [ "3", "5", ], // read from /etc/init.d/rc?.d/* links

	"started" : 0, // return from rcservice status (integer)

	"dirty" : false, // was the entry changed?
      ]</pre>
     */
    //
    //

    /**
     * Get service info without peeking if service runs.
     * @param name name of the service
     * @return service information
     */
    global define map ServiceInfo (string name) ``{
	// Fhis is an info achieved just by a call of
	// the 2 main agent calls. Nothing about service
	// status is beeing obtained.
	if (!SCR::Read (.init.scripts.exists, name))
	    return $[];
	map detail = lookup (SCR::Read (.init.scripts.runlevel, name), name, $[]);
	map service = lookup (SCR::Read (.init.scripts.comment, name), name, $[]);
	return add (
	    add (service, "start", lookup (detail, "start", [])),
	    "stop", lookup (detail, "stop", []));
    }

    /**
     * Get service status. It is output from "rcservice status".
     * It should conform to LSB. 0 means running.
     * @param name name of the service
     * @return init script exit status
     */
    global define integer ServiceStatus (string name) ``{
	if (!SCR::Read (.init.scripts.exists, name))
	    return -1;
	return SCR::Execute (.target.bash, sformat ("/etc/init.d/%1 status", name), $["TERM":"raw"]);
    }
    /**
     * Get service info and finds out whether service is running.
     * @param name name of the service
     * @return service map
     */
    global define map ServiceFullInfo (string name) ``{
	if (!SCR::Read (.init.scripts.exists, name))
	    return $[];
	return add (ServiceInfo (name), "started", ServiceStatus (name));
    }

    /**
     * Adjust runlevels in which service runs.
     * @param name service name
     * @param action "disable" -- remove links, "enable" -- if there are
     *    no links, set default, otherwise do nothing, "default" -- set
     *    defaults.
     * @return success state
     * FIXME: think about enabling portmapper
     */
    global define boolean ServiceAdjust (string name, string action) ``{
	if (!SCR::Read (.init.scripts.exists, name))
	{
	    y2error ("Init script %1 does not exist.", name);
	    return false;
	}
	map service = ServiceInfo (name);
	if ("disable" == action)
	{
	    if (size (lookup (service, "start", [])) != 0)
	    {
		if (0 != SCR::Execute (.target.bash, sformat ("/sbin/insserv -r %1", name)))
		    return false;
	    }
	    return true;
	}
	if ("enable" == action)
	{
	    if (size (lookup (service, "start", [])) == 0)
	    {
		if (0 != SCR::Execute (.target.bash, sformat ("/sbin/insserv -d %1", name)))
		    return false;
	    }
	    return true;
	}
	if ("default" == action)
	{
	    return ((0 != SCR::Execute (.target.bash, sformat ("/sbin/insserv -d %1", name))))
		? false : true;
	}
	y2error ("ServiceAdjust: bad action %1", action);
	return false;
    }

    /**
     * Set service to run in selected runlevels.
     * @param name name of service to adjust
     * @param rl list of runlevels in which service should start
     * @return success state
     */
    global define boolean ServiceFinetune (string name, list rl) ``{
	if (!SCR::Read (.init.scripts.exists, name))
	{
	    y2error ("Init script %1 does not exist.", name);
	    return false;
	}
	string fill = "";
	string out = "";
	foreach (`i, rl, ``{
	    out = out + fill + sformat ("%1", i);
	    fill = ",";
	});
	if ("" == out)
	    return SCR::Execute (.target.bash, sformat ("/sbin/insserv -r %1", name));
	return 0 == SCR::Execute (.target.bash, sformat ("/sbin/insserv %1,start=%2", name, out));
    }

    /**
     * Run init script.
     * @param name init service name
     * @param param init script argument
     * @return integer exit value
     */
    global define integer RunInitScript (string name, string param) ``{
	return SCR::Execute (.target.bash, sformat ("/etc/init.d/%1 %2", name, param), $[ "TERM" : "raw"]);
    }

    /**
     * Run init script and return also its output.
     * @param name init service name
     * @param param init script argument
     * @return map of $[ "stdout" : "...", "stderr" : "...", "exit" : int,]
     */
    global define map RunInitScriptOutput (string name, string param) ``{
	return SCR::Execute (.target.bash_output, sformat ("/etc/init.d/%1 %2", name, param), $[ "TERM" : "raw"]);
    }

    /*
     * The above interface was very public. Now there is interface for
     * package.
     */

    /**
     * List of all services. Each item is a map described above.
     */
    global map services = $[];

    /**
     * List of all service names.
     */
    global list service_list = [];

    /**
     * Default runlevel (after boot)
     */
    global string default = "";
    /**
     * Backup of default runlevel.
     */
    string default_orig = "";

    /**
     * List of all runlevels available in the system.
     */
    global list runlevels = [];

    /**
     * Current runlevel
     */
    global string current = "";

    /**
     * Read settings
     */
    global define boolean Read () ``{
	Progress::Simple (_("Initializing runlevel editor. Please wait."), " ", 6, "");
	Progress::NextStep ();
	runlevels= SCR::Read (.init.scripts.runlevel_list);
	if (0 == size (runlevels))
	{
	    runlevels = ["0", "1", "2", "3", "5", "6", "S", ];
	}
	Progress::NextStep ();

	current = SCR::Read (.init.scripts.current_runlevel);
	Progress::NextStep ();

	//..
	default= SCR::Read (.init.scripts.default_runlevel);
	default_orig = default;
	Progress::NextStep ();

	map details = SCR::Read (.init.scripts.runlevels);
	Progress::NextStep ();
	services = SCR::Read (.init.scripts.comments);
	Progress::NextStep ();
	services = mapmap (`k, `v, services, ``{
	    // play tennis
	    map second_service = lookup (details, k, $[]);
	    service_list = add (service_list, k);
	    v = add (v, "start", lookup (second_service, "start", []));
	    v = add (v, "stop" , lookup (second_service, "stop",  []));
	    return [ k, v ];
	});
	Progress::NextStep ();
	return true;
    }

    /**
     * Set all dirty services as clean and tries to read
     * original "start"/"stop" for them.
     */
    global define void ClearServices () ``{
	services = mapmap (`k, `v, services, ``{
	    if (lookup (v, "dirty", false))
	    {
		v = add (v, "dirty", false);
		map r = SCR::Read (.init.scripts.runlevel, k);
		r = lookup (r, k, $[]);
		v = add (v, "start", lookup (r, "start", []));
		v = add (v, "stop", lookup (r, "stop", []));
	    }
	    return [k, v];
	});
    }

    /**
     * Is service disabled? Check "disabled" key which reflects whether service is disabled by some START_-like variable.
     * Otherwise it checks if it is disabled by unchecking all checkboxes...
     * @param service service to check
     * @return boolean true if service is disabled
     */
    global define boolean isDisabled (map service) ``{
	return 0 == size (lookup (service, "start", []));
    }

    /**
     * If nfsserver runs, portmap has to run too.
     * @return string name of the first enabled service that requires portmap
     */
    global define string AdjustNfsserver () ``{
	if (!isDisabled (lookup (services, "portmap", $[])))  // if portmap is enabled, there is no problem
	    return nil;
	string req = nil;
	list in = [];
	foreach (`k, `v, services, ``{
	    if (contains (lookup (v, "reqstart", []), "portmap") && size (lookup (v, "start", [])) > 0)
	    {
		in = union (in, toset (lookup (v, "start", [])));
		if (nil == req)
		    req = k;
	    }
	});
	if (size (in) > 0)
	{
	    y2error ("Enabling portmap in %1", in);
	    map service = lookup (services, "portmap", $[]);
	    services = add (services, "portmap",
		    union (service,
			$[
			"start": in,
			"dirty": true,
			]));
	    return req;
	}
	return nil;
    }
    /**
     * If inetd and xinetd are enabled together, show a warning.
     * @return are both of them enabled?
     */
    global define boolean CheckXInetd () ``{
	return !isDisabled (lookup (services, "inetd", $[])) && !isDisabled (lookup (services, "xinetd", $[]));
    }

    /**
     * Save changed services into proper runlevels. Save also changed
     * default runlevel.
     */
    global define void Write () ``{
	integer prsize = size (services);
	Progress::Simple (_("Saving changes to runlevels."), " ", prsize + 1, "");

	if (default != default_orig)
	    SCR::Write (.init.scripts.default_runlevel, default);
	Progress::NextStep ();

	AdjustNfsserver ();

	foreach (`k, `v, services, ``{
	    Progress::Title (sformat (_("Service %1"), k));
	    if (lookup (v, "dirty", false))
	    {
		// save!
		string add_comma = "";
		list start = lookup (v, "start", []);
		if (contains (lookup (v, "defstart", []), "B"))
		{
		    start = union (start, [ "B" ]);
		}
		string commandline = "";
		if (size (start)>0)
		{
		    commandline = sformat ("/sbin/insserv %1,start=", k);
		    foreach (`i, start, ``{
			commandline = commandline + add_comma + i;
			add_comma = ",";
		    });
		}
		else
		{
		    commandline = sformat ("/sbin/insserv -r %1", k);
		}
		y2milestone ("%1 ===> Running %2", k, commandline);
		SCR::Execute (.target.bash, commandline);
	    }
	    Progress::NextStep ();
	});
	Progress::NextStep ();
    }

    /**
     * Were some settings changed?
     * @return true if yes
     */
    global define boolean isDirty () ``{
	if (default != default_orig)
	    return true;

	boolean dirty = false;
	foreach (`k, `v, services, ``{
	    if (dirty)
	    {
		return ;
	    }
	    if (lookup (v, "dirty", false))
	    {
		dirty = true;
	    }
	});
	return dirty;
    }

    /**
     * Returns true if any link in /etc/init.d/rc?.d/ exists for this
     * script. If service does not exist, logs an error.
     * @param name service name
     * @return true if service is set to run in any runlevel
     */
    global define boolean ServiceEnabled (string name) ``{
	// Fhis is an info achieved just by a call of
	// the 2 main agent calls. Nothing about service
	// status is beeing obtained.
	if (!SCR::Read (.init.scripts.exists, name))
	{
	    y2error ("Service does not exist: %1", name);
	    return false;
	}
	map detail = lookup (SCR::Read (.init.scripts.runlevel, name), name, $[]);
	return 0 != size (lookup (detail, "start", []));
    }

    /**
     * Export user settings.
     * @return user settings
     */
    global define map Export () ``{
	AdjustNfsserver ();
	map svc = filter (`k, `v, services, ``{
	    return lookup (v, "dirty", false);
	});
	map ret = $[ "services" : svc ];
	if (default != default_orig)
	{
	    ret = add (ret, "default", default);
	}
	return ret;
    }
    /**
     * Import user settings
     * @param s user settings
     * @return success state
     */
    global define boolean Import (map s) ``{
	runlevels= SCR::Read (.init.scripts.runlevel_list);
	if (0 == size (runlevels))
	{
	    runlevels = ["0", "1", "2", "3", "5", "6", "S", ];
	}

	//..
	default= SCR::Read (.init.scripts.default_runlevel);
	default_orig = default;

	map details = SCR::Read (.init.scripts.runlevels);
	services = SCR::Read (.init.scripts.comments);
	services = mapmap (`k, `v, services, ``{
	    // play tennis
	    map second_service = lookup (details, k, $[]);
	    service_list = add (service_list, k);
	    v = add (v, "start", lookup (second_service, "start", []));
	    v = add (v, "stop" , lookup (second_service, "stop",  []));
	    return [ k, v ];
	});
	// and finaly process map beeing imported
	map new = lookup (s, "services", $[]);
	if (size (new) > 0)
	{
	    foreach (`k, `v, new, ``{
		if (nil == lookup (services, k, nil))
		{
		    y2milestone ("Service %1 is not installed on target system, adding it by hand.", k);
		}
		v = add (v, "dirty", true);
		services = add (services, k, v);
	    });
	}
	// default
	if (haskey (s, "default"))
	{
	    default = lookup (s, "default", nil);
	    default_orig = "---";
	}
	return true;
    }
}
