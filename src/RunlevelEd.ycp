/**
 * File:
 *   RunlevelEd.ycp
 * Package:
 *   Runlevel Editor
 * Summary:
 *   Data for configuration of services, input and output functions.
 *
 * Authors:
 *   Martin Vidner <mvidner@suse.cz>
 *   Petr Blahos <pblahos@suse.cz>
 *
 * $Id$
 */

{
    module "RunlevelEd";
    textdomain "runlevel";

    import "Runlevel";
    import "Progress";
    import "Summary";
    import "Report";

    include "runlevel/toposort.ycp";

    /**
     * @struct service
     * One service is described by such map: <pre>
      "servicename" : $[
	"defstart" : [ "2", "3", "5", ], // Default-Start comment
	"defstop"  : [ "0", "1", "6", ], // Default-Stop  comment

	// "should" dependencies (+) are filtered by addRequires
	"reqstart" : [ "$network", "portmap" ], // Required-Start comment
	"reqstop"  : [ "$network", "portmap" ], // Required-Stop  comment

	"description" : "text...",       // Description comment

	// which runlevels service is really started/stopped in
	// read from /etc/init.d/{rc?,boot}.d/* links
	//
	// Note that the boot process (init.d/boot.d) is considered
	// a "B" runlevel that is implicitly contained in the other runlevels.
	// Using
	//   list st = services ["boot.local", "start"]:[]
	//   contains (st, "3") // DON'T
	// results in false but that's probably not what you want.
	// Use
	//   StartContainsImplicitly (st, "3")
	// which tests for "3" and "B".
	"start" : [ "3", "5", ],
	"stop"  : [ "3", "5", ],

	"started" : 0, // return from rcservice status (integer)

	"dirty" : false, // was the entry changed?
      ]</pre>
     */
    //
    //


    /**
     * List of all services. Each item is a map described above.
     * @ref service
     */
    global map services = $[];

    /**
     * List of all service names.
     */
    global list service_list = [];

    /**
     * Default runlevel (after boot)
     */
    global string default = "";
    /**
     * Backup of default runlevel.
     */
    string default_orig = "";

    /**
     * List of all runlevels available in the system.
     */
    global list runlevels = [];

    /**
     * Current runlevel
     */
    global string current = "";

    /* Dependency solving: */
    /**
     * ONLY ONE SCRIPT provides a facility in this model.
     * In SuSE packages, the only exception are sendmail and postfix
     * both providing sendmail but they cannot be installed together
     * anyway.
     * atd has Provides: at, so
     *   what_provides["at"] == "atd";
     * Identity is not represented explicitly: ypbind has Provides: ypbind, but
     *   haskey (what_provides, "ypbind") == false;
     */
    map what_provides = $[];

    /**
     * System facility definitions
     * "should" dependencies (+) are filtered by addRequires
     * /etc/insserv.conf:
     *   system_requires["$network"] == ["network", "+pcmcia", "+hotplug"];
     */
    map system_requires = $[];

    /**
     * Read settings
     * @return success
     */
    global define boolean Read () ``{
	// progress caption
	Progress::Simple (_("Initializing runlevel editor. Please wait."), " ", 7, "");
	Progress::NextStep ();
	runlevels= SCR::Read (.init.scripts.runlevel_list);
	if (0 == size (runlevels))
	{
	    runlevels = ["0", "1", "2", "3", "5", "6", "S", ];
	}
	Progress::NextStep ();

	current = SCR::Read (.init.scripts.current_runlevel);
	Progress::NextStep ();

	//..
	default= SCR::Read (.init.scripts.default_runlevel);
	default_orig = default;
	Progress::NextStep ();

	system_requires = SCR::Read (.init.insserv_conf);
	Progress::NextStep ();

	map details = SCR::Read (.init.scripts.runlevels);
	Progress::NextStep ();
	services = SCR::Read (.init.scripts.comments);
	Progress::NextStep ();
	services = mapmap (string k, map v, services, ``{
	    foreach (string f, v["provides"]:[], ``{
		// identity implicit; only the first script provides a facility
		if (f != k && !haskey (what_provides, f))
		{
		    what_provides = add (what_provides, f, k);
		}
	    });

	    service_list = add (service_list, k);


	    // play tennis
	    map second_service = lookup (details, k, $[]);
	    v = add (v, "start", lookup (second_service, "start", []));
	    v = add (v, "stop" , lookup (second_service, "stop",  []));
	    return [ k, v ];
	});
	buildRequires ();
	what_requires = ReverseGraph (requires);
	Progress::NextStep ();
	return true;
    }

    /**
     * A graph where nodes are scripts or system facilities
     * but not normal facilities (ie. provides are solved).
     */
    map requires = $[];
    /**
     * Like "requires" but in reverse direction.
     * Used for stopping and disabling services.
     */
    map what_requires = $[];
    /**
     * If there's a dependency loop, dependency checking is disabled.
     */
    boolean dependencies_disabled = false;
    /**
     * Create requires from services, system_requires and what_provides.
     */
    define void buildRequires () ``{
	foreach (string service, map comments, services, ``{
	    addRequires (service, comments["reqstart"]:[]);
	});
	foreach (string sys_f, list req, system_requires, ``{
	    addRequires (sys_f, req);
	});
    }
    /**
     * Resolve provides, filter out "should" dependencies (+)
     * and add the requirements to "requires".
     * Missing services are not detected.
     * @param service a service
     * @param req_facilities its required facilities
     */
    define void addRequires (string service, list(string) req_facilities) ``{
	list req_s = filter (string f, req_facilities,
			     ``( substring (f, 0, 1) != "+"));
	req_s = maplist (string f, req_s, ``( what_provides[f]:f ));
	requires = add (requires, service, req_s);
    }

    /**
     * Resolve which services need to be enabled/disabled
     * @param service a service
     * @param enable enabling or disabling a service?
     * @return a list of services (excluding itself) required to start
     * a service (enable) or to be stopped because they require the
     * service (disable), ordered by their dependencies. Missing
     * services are included, system facilities excluded.<br>
     * If dependencies are disabled, returns an empty list, as if
     * there were no dependencies.
     */
    global define list(string) ServiceDependencies (string service,
						    boolean enable) ``{
	if (dependencies_disabled)
	{
	    return [];
	}
	// make a dependency subgraph
	map s_req = ReachableSubgraph (enable? requires: what_requires,
				       service);
	y2debug ("DEPGRAPH %1: %2", service, s_req);
	// sort it
	list r = TopologicalSort (s_req);
	list sorted = r[0]:[];
	list rest = r[1]:[];
	if (size (rest) > 0)
	{
	    // TODO: localize the loop, disable it only locally
	    // and say what scripts form it
	    Report::Error (_("A dependency loop was detected.
Further dependency checking will be disabled."));
	    dependencies_disabled = true;
	}

	// filter system facilities
	sorted = filter (string f, sorted, ``(substring (f, 0, 1) != "$"));
	// remove the original service
	sorted = remove (sorted, 0);
	// reverse it so that the required services are first
	return reverse (sorted);
    }

    /**
     * Argh, not a builtin
     * @param l a list
     * @return reversed list
     */
    define list reverse (list l) ``{
	if (l == nil)
	{
	    return nil;
	}
	list result = [];
	foreach (any item, l, ``{
	    result = prepend (result, item);
	});
	return result;
    }

    /**
     * Filter out already started/stopped services.
     * @param svcs	service list to be started/stopped
     * @param start	start/stop
     * @return a list of scripts that must really be started/stopped
     */
    global define list(string) FilterStartStop (list(string) svcs,
						boolean start) ``{
	return filter (string service, svcs, ``{
	    boolean started =
		services[service, "started"]:-1 == 0 ||
		// boot scripts are always considered to be started,
		// even if they return 4 :(
		services[service, "defstart"]:[] == [ "B" ] ||
		// and while we're at it with kludges,
		// pretend nfs is running (ie. /usr is available)
		// because it reports 3 when no nfs imports are defined :(
		// TODO resolve it better!
		service == "nfs";
	    // keep it in the list if the wanted result
	    // is different from the current state
	    return start != started;
	});
    }
    /**
     * Filter out already enabled/disabled services.
     * @param svcs	service list to be enabled/disabled
     * @param rl	which runlevel
     * @param enable	enabling or disabling?
     * @return a list of scripts that must really be enabled/disabled
     */
    global define list(string) FilterEnableDisable (list(string) svcs,
						    string rl,
						    boolean enable) ``{
	return filter (string service, svcs, ``{
	    list start = services[service, "start"]:[];
	    // keep it in the list if the wanted result
	    // is different from the current state
	    return enable != StartContainsImplicitly (start, rl);
	});
    }
    /**
     * Filter out already enabled/disabled services.
     * @param svcs	service list to be enabled/disabled
     * @param rls	which runlevels (all of them).
     *  For disabling, must be nil, meaning disable in all.
     * @param enable	enabling or disabling?
     * @return a list of scripts that must really be enabled/disabled
     */
    global define list(string) FilterEnableDisableSet (list(string) svcs,
						    list(string) rls,
						    boolean enable) ``{
	if (enable)
	{
	    return filter (string service, svcs, ``{
		list start = services[service, "start"]:[];
		// keep it in the list
		// if it should start in a bigger set than now
		return !ImplicitlySubset (rls, start);
	    });
	}
	else
	{
	    if (rls != nil)
	    {
		// should not happen
		y2error ("Disabling in a nontrivial set of runlevels (%1) not implemented.", rls);
		return nil;
	    }
	    else
	    {
		return filter (string service, svcs, ``{
		    list start = services[service, "start"]:[];
		    // keep it in the list
		    // if it is enabled now
		    return start != [];
		});
	    }
	}
    }

    /**
     * Is a service started in a runlevel, given the list of rulevels
     * it is started in?
     * This looks like a simple contains,
     * but "B" implicitly expands to all runlevels.
     * See also bug #17234.
     * @param rls runlevels the service is started in
     * @param rl  which runlevel is tested
     * @return should it be running in rl?
     */
    global define boolean StartContainsImplicitly (list(string) rls,
						   string rl) ``{
	return contains (rls, "B") || contains (rls, rl);
    }
    /**
     * Whether a set of runlevels is a subset of another set of runlevels.
     * But expands "B" to the whole set
     */
    define boolean ImplicitlySubset (list(string) rls_a,
					    list(string) rls_b) ``{
	return contains (rls_b, "B") || subset (rls_a, rls_b);
    }

    /**
     * @param a a set
     * @param b a set
     * @return a \subseteq b
     */
    define boolean subset (list a, list b) ``{
	return size (union (a, b)) <= size (b);
    }

    /**
     * Set all dirty services as clean and tries to read
     * original "start"/"stop" for them.
     */
    global define void ClearServices () ``{
	services = mapmap (`k, `v, services, ``{
	    if (lookup (v, "dirty", false))
	    {
		v = add (v, "dirty", false);
		map r = SCR::Read (.init.scripts.runlevel, k);
		r = lookup (r, k, $[]);
		v = add (v, "start", lookup (r, "start", []));
		v = add (v, "stop", lookup (r, "stop", []));
	    }
	    return [k, v];
	});
    }

    /**
     * Is a service disabled?
     * Checks whether the list of runlevels it runs in is empty
     * @param service service to check
     * @return boolean true if service is disabled
     */
    global define boolean isDisabled (map service) ``{
	return 0 == size (lookup (service, "start", []));
    }

    /**
     * Check for portmap. Portmap should be started if inetd, nfs,
     * nfsserver, nis, ... is started. This checks the dependency.
     * @return string name of the first enabled service that requires portmap
     */
    global define string CheckPortmap () ``{
	if (!isDisabled (lookup (services, "portmap", $[])))  // if portmap is enabled, there is no problem
	    return nil;
	string req = nil;
	list in = [];
	foreach (`k, `v, services, ``{
	    if (contains (lookup (v, "reqstart", []), "portmap") && size (lookup (v, "start", [])) > 0)
	    {
		in = union (in, toset (lookup (v, "start", [])));
		if (nil == req)
		    req = k;
	    }
	});
	return size (in) > 0 ? req : nil;
    }
    /**
     * If inetd and xinetd are enabled together, show a warning.
     * @return are both of them enabled?
     */
    global define boolean CheckXInetd () ``{
	return !isDisabled (lookup (services, "inetd", $[])) && !isDisabled (lookup (services, "xinetd", $[]));
    }

    /**
     * Save changed services into proper runlevels. Save also changed
     * default runlevel.
     */
    global define void Write () ``{
	integer prsize = size (services);
	// progress caption
	Progress::Simple (_("Saving changes to runlevels."), " ", prsize + 1, "");

	if (default != default_orig)
	    SCR::Write (.init.scripts.default_runlevel, default);
	Progress::NextStep ();

	foreach (`k, `v, services, ``{
	    if (lookup (v, "dirty", false))
	    {
		// progress item, %1 is a service (init script) name
		Progress::Title (sformat (_("Service %1"), k));
		// save!
		list start = lookup (v, "start", []);
		/*
		// This was an additional safety measure.
		// The dependencies and the easy mode make it obsolete.
		// #21214
		if (contains (lookup (v, "defstart", []), "B"))
		{
		    start = union (start, [ "B" ]);
		}
		*/
		Runlevel::ServiceFinetune (k, start);
	    }
	    else
		// progress item, %1 is a service (init script) name
		Progress::Title (sformat (_("Skipping service %1."), k));
	    Progress::NextStep ();
	});
	Progress::NextStep ();
    }

    /**
     * Were some settings changed?
     * @return true if yes
     */
    global define boolean isDirty () ``{
	if (default != default_orig)
	    return true;

	boolean dirty = false;
	foreach (`k, `v, services, ``{
	    if (dirty)
	    {
		return ;
	    }
	    if (lookup (v, "dirty", false))
	    {
		dirty = true;
	    }
	});
	return dirty;
    }

    /**
     * Export user settings.
     * @return user settings:<pre>$[
     *    "services": $[ map of dirty services ],
     *    "default":  the default runlevel, if changed,
     *]</pre>
     */
    global define map Export () ``{
	map svc = filter (`k, `v, services, ``{
	    return lookup (v, "dirty", false);
	});
	list tmp_services = maplist(string service_name, map service_data, svc, ``{
	    string  service_start = mergestring(lookup(service_data,"start",[]), " ");
	    string service_stop = mergestring(lookup(service_data,"stop",[]), " ");

	    map service_map = $[];
	    service_map["service_name"] = service_name;
	    if (size(service_start) > 0 )
	    {
		service_map["service_start"] = service_start;
	    }
	    if (size(service_stop) > 0 )
	    {
		service_map["service_stop"] = service_stop;
	    }

	    return (service_map);
	});
	map ret = $[ "services" : tmp_services ];
	if (default != default_orig && default != "")
	{
	    ret = add (ret, "default", default);
	}
	return ret;
    }
    /**
     * Import user settings
     * @param s user settings
     * @see Export
     * @return success state
     */
    global define boolean Import (map s) ``{
	runlevels= SCR::Read (.init.scripts.runlevel_list);
	if (0 == size (runlevels))
	{
	    runlevels = ["0", "1", "2", "3", "5", "6", "S", ];
	}

	//..
	default= SCR::Read (.init.scripts.default_runlevel);
	default_orig = default;

	// and finaly process map being imported
	list new = s["services"]:[];
	map tmp_services = listmap(map service, new,  ``{
	    string name = service["service_name"]:"";
	    list stop = [];
	    list start = [];
	    if (haskey(service, "service_status"))
	    {
		if (service["service_status"]:"" == "enable")
		{
		    map info = Runlevel::ServiceInfo(name);
		    y2milestone("service info for %1: %2", name, info);
		    start = info["start"]:[];
		    stop = info["stop"]:[];
		}
		else if (service["service_status"]:"" == "disable")
		{
		    start = [];
		    stop = [];
		}
	    }
	    else
	    {
		start = splitstring(service["service_start"]:"", " ");
		stop = splitstring(service["service_stop"]:"", " ");
	    }

	    map service_map = $[];
	    if (size(start) > 0 )
	    service_map = add(service_map,"start",start);
	    if (size(stop) > 0 )
	    service_map = add(service_map,"stop",stop);
	    return([name,service_map]);
	});

	if (size (tmp_services) > 0)
	{
	    foreach (`k, `v, tmp_services, ``{
		if (nil == lookup (services, k, nil))
		{
		    y2milestone ("Service %1 is not installed on target system, adding it by hand.", k);
		}
		v = add (v, "dirty", true);
		services = add (services, k, v);
	    });
	}
	else
		services = $[];
	// default
	if (haskey (s, "default"))
	{
	    default = lookup (s, "default", nil);
	    default_orig = "---";
	}
	return true;
    }

    /**
     * @return Html formatted configuration summary
     */
    global define string Summary()
	``{

	map rl = $[
	    // summary item: description of a run level
	    "0" : _("0: System halt"),
	    // summary item: description of a run level
	    "1" : _("1: Single user mode"),
	    // summary item: description of a run level
	    "2" : _("2: Local multiuser without remote network"),
	    // summary item: description of a run level
	    "3" : _("3: Full multiuser with network"),
	    // summary item: description of a run level
	    "4" : _("4: User defined"),
	    // summary item: description of a run level
	    "5" : _("5: Full multiuser with network and xdm"),
	    // summary item: description of a run level
	    "6" : _("6: System reboot"),
	    ];

	string sum = "";
	// summary header
	sum = Summary::AddHeader(sum, _("Current Runlevel"));
	sum = Summary::AddLine(sum,  rl[default]:"");
	// summary header
	sum = Summary::AddHeader(sum, _("Services"));

	if (size(services)>0) {
	    sum = Summary::OpenList(sum);
	    foreach(string k, map v, services, ``{
		if (v["dirty"]:false)
		{
		    string item = sformat (
			// summary item: %1 service name,
			// %2, %3 list of runlevels it starts/stops in
			_("<p><b>%1</b><br> Start: %2</p>"),
			k,
			mergestring(v["start"]:[], " ")
			);
		    sum = Summary::AddListItem(sum, item );
		}
	    });
	    sum = Summary::CloseList(sum);
	}
	else
	{
	    sum =  Summary::AddLine(sum, Summary::NotConfigured());
	}
	return sum;
    }

}
