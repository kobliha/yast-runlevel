/**
 * File:
 *   ui.ycp
 *
 * Module:
 *   Runlevel Editor
 *
 * Summary:
 *   Runlevel Editor user interface.
 *
 * Authors:
 *   Petr Blahos <pblahos@suse.cz>
 *
 * $Id$
 *
 * Runlevel editor user interface functions.
 */

{
    textdomain "runlevel";

    import "Runlevel";
    include "ui/common_popups.ycp";

    /**
     * Create term of checkboxes for runlevel selection.
     * @return HBox full of checkboxes.
     */
    global define term getRlCheckBoxes () ``{
	term rls = `HBox (`opt (`hstretch));
	foreach (`i, Runlevel::runlevels, ``{
	    if (size (rls) > 1)
		rls = add (rls, `HStretch ());
	    rls = add (rls, `CheckBox (`id (i), `opt (`notify), "&" + i));
	});
	return rls;
    }
    /**
     * Changes values of runlevel checkboxes.
     * @param service @ref service
     */
    global define void updateRlCheckBoxes (map service) ``{
	list start = service["start"]:[];
	foreach (`i, Runlevel::runlevels, ``{
	    UI::ChangeWidget (`id (i), `Value, contains (start, i));
	});
    }
    /**
     * Sets runlevel columns in the table.
     * @param service_name which line
     * @param service @ref service
     */
    global define void updateRlColumns (string service_name, map service) ``{
	list start = service["start"]:[];
	foreach (`i, Runlevel::runlevels, ``{
	    UI::ChangeWidget (`id (`table),
			      `Item (service_name, runlevel2tableindex[i]:0),
			      contains (start, i) ? i : " ");
	});
    }
    /**
     * Helper function for fetching service status in run-time.
     * @param service_name which line
     * @param started status or -1 (unknown yet)
     */
    global define void updateStatusColumn (string service_name,
					   integer started) ``{
	UI::ChangeWidget (`id (`table), `Item (service_name, 1),
			  StartedText (started));
    }
    /**
     * Reads data from checkboxes and updates service
     * and Runlevel::services maps.
     * @param service_name which service
     * @param service @ref service
     * @return @ref service
     */
    global define map queryRlCheckBoxes (string service_name, map service) ``{
	list start_in = [];
	foreach (`i, Runlevel::runlevels, ``{
	    if (UI::QueryWidget (`id (i), `Value))
	    {
		start_in = add (start_in, i);
	    }
	});
	if (service["start"]:[] != start_in)
	{
	    service = add (add (service, "start", start_in), "dirty", true);
	    Runlevel::services = add (Runlevel::services, service_name,
				      service);
	}
	return service;
    }

    /**
     * Get help text for rcscript start|stop command exit value.
     * @param exit exit value
     * @return string help text
     */
    global define string getActionReturnHelp (integer exit) ``{
	return lookup ($[
	   // Init script non-status-command return codes
	   // http://www.linuxbase.org/spec/gLSB/gLSB/iniscrptact.html
		0: _("Success."),  // this is not used but in case someone called this function with bad input
		2: _("Invalid or excess arguments."),
		3: _("Unimplemented feature."),
		4: _("User had insufficient privileges."),
		5: _("Program is not installed."),
		6: _("Program is not configured."),
		7: _("Program is not running."),
		], exit, _("Unspecified error."));
    }
    /**
     * Get help text for rcscript status return value
     * according to LSB.
     * @param exit exit value
     * @return string help text
     */
    global define string getStatusReturnHelp (integer exit) ``{
	return lookup ($[
	   // Init script "status" command return codes
	   // http://www.linuxbase.org/spec/gLSB/gLSB/iniscrptact.html
		0: _("Program is running."),
		1: _("Program is dead and /var/run pid file exists."),
		2: _("Program is dead and /var/lock lock file exists."),
		3: _("Program is stopped."),
		4: _("Program or service status is unknown."),
		], exit, _("Unspecified error."));
    }
    /**
     * help text for progress
     * @return help text
     */
    global define string getHelpProgress () ``{
	return
	    // help text
	    _("<P><BIG><B>Runlevel editor initialization</B></BIG><BR>
Please wait.</P>")
	    +
	    // warning
	    _("<p><b>Note!</b> The runlevel editor is an expert tool. Please only change settings if
 you know what you are doing; otherwise your system might not function properly afterwards.</p>")
	    ;
    }

    /**
     * help text for main dialog
     * @return help text
     */
    global define string getHelpMain () ``{
	return
	    // help text
	    _("<p><b>With the runlevel editor you can set the default runlevel and specify in detail
 which system services you want to be started in which runlevel.</b></p>")
	    +
	    // warning
	    _("<p><b>Warning!</b> The runlevel editor is an expert tool. Only change settings if you know
 what you are doing, otherwise your system might not function properly afterwards.</p>")
	    +
	    // The change does not occur immediately. After a reboot the system boots into the specified runlevel.
	    _("<p>Changes to the <b>default runlevel</b> will take effect next time you boot your computer.</p>")
	    +
	    _("<p>To change the behavior of runlevels and system services in detail, click <b>Runlevel properties</b>.
 You will also be able to start and stop services directly.</p>
")
	    ;
    }

    /**
     * help text services dialog
     * @return help text
     */
    global define string getHelpComplex () ``{
	// help text
	return
	    // help text
	    _("<p>Assign system services to runlevels by selecting the list entry of the respective service then
checking or unchecking the <b>check boxes B-S</b> for the runlevel.</p>
")
	    +
	    _("<p><b>Start/Stop/Refresh:</b> Use this to start or stop services individually.</p>")
	    +
	    // help text
	    _("<P><B>Set/Reset:</B>
Select runlevels in which to run currently selected service.<ul>
<li><b>Enable the service:</b> Activates the service in the standard runlevels.</li>
<li><b>Disable the service:</b> Deactivates service.</li>
<li><b>Enable all services:</b> Activates all services in their standard runlevels.</li>
</ul></p>")
	    ;
    }
    /**
     * Help text for auto-complex-screen
     * @return help text
     */
    global define string getHelpAuto () ``{
	return
	    // help text
	    _("<p><b>Prepare data for autoinstallation.</b></p>")
	    +
	    _("<p>Change the services to requested state. Only services marked as changed will be really changed in target system.</p>")
	    +
	    _("<p>If you made a mistake and want to undo the change, press <b>Clear</b> or <b>Clear all</b></p>")
	    ;
    }

    /**
     * Ask if really abort. Uses boolean changed_settings. Sets boolean do_abort_now.
     * @return boolean true if user really wants to abort
     */
    global define boolean reallyAbort ()``{
	if (do_abort_now || !Runlevel::isDirty ())
	    {
		do_abort_now = true;
		return true;
	    }
	do_abort_now = UI::ReallyAbortPopup (true);
	return do_abort_now;
    }

    /**
     * @param started status or -1 (unknown yet)
     * @return "Yes", "No" or "???"
     */
    global define string StartedText (integer started) ``{
	// ???: we do not know what is the service state
	return (0 == started ? _("Yes") :
		(started > 0 ? _("No") : _("???")));
    }
    /**
     * Create table items from services.
     * @return list List of items for table.
     */
    global define list servicesToTable () ``{
	list items = [];
	boolean first = true;
	foreach (`k, `v, Runlevel::services, ``{
	    if (first)
	    {
		first = false;
		current_service = k;
	    }
	    term item = `item (`id (k), k);
	    integer started = lookup (v, "started", -1);
	    item = add (item, StartedText (started));
	    list rl = lookup (v, "start", []);
	    foreach (`i, Runlevel::runlevels, ``{
		item = add (item, (contains (rl, i)? i : " "));
	    });
	    item = add (item, lookup (v, "description", ""));
	    items = add (items, item);
	});
	return items;
    }

    /**
     * For each service, determines its status and calls a supplied function.
     * @param func function to call
     * @see updateStatusInTable
     */
    global define void serviceStatusIterator (term func) ``{
	if (!fetching_service_status)
	{
	    return;
	}
	if (fetching_service_index >= size (Runlevel::service_list))
	{
	    fetching_service_status = false;
	    return;
	}
	string service_name = Runlevel::service_list[fetching_service_index]:"";
	fetching_service_index = fetching_service_index + 1;
	map service = Runlevel::services[service_name]:$[];
	integer started = Runlevel::RunInitScript (service_name, "status");

	Runlevel::services = add (Runlevel::services, service_name,
				  add (service, "started", started));
	if (func != nil)
	{
	    func = add (func, service_name);
	    func = add (func, service);
	    func = add (func, started);
	    eval (func);
	}
    }

    /**
     * Dialog that allows changing of default runlevel.
     * @return symbol for wizard sequencer
     */
    global define symbol runMain () ``{

	term contents = `VBox (
	    `VStretch (),
	    // label in dialog
	    `HBox (
		`HSpacing (1),
		`Frame (
		    _("Default runlevel"),
		    `HBox (
			`HSpacing (2),
			`VBox (
			    `VSpacing (1),
			    `Label (`opt (`hstretch),_("Current runlevel is:")),
			    `Label (`opt (`outputField, `hstretch), getRunlevelDescr (Runlevel::current)),
			    `VSpacing (1),
			    // combo box label
			    `ComboBox (`id (`default), `opt (`hstretch), _("&Set default runlevel after booting to:"), getDefaultPicker ()),
			    `VSpacing (1)
			    ),
			`HSpacing (2)
			)
		    ),
		`HSpacing (1)
		),
	    `VStretch (),
	    // pushbutton
	    `PushButton (`id (`edit), _("Runlevel &properties...")),
	    `VStretch ()
	    );
	// window label
	Wizard::SetContents (_("Runlevel editor: default runlevel"), contents, getHelpMain (), true, true);
	Wizard::ReplaceNextButton (`PushButton (`id (`next), FinishButtonLabel()));

	any ret = nil;
	while (true)
	{
	    if (fetching_service_status)
	    {
		ret = UI::PollInput ();
		UI::NormalCursor ();
		if (nil == ret)
		{
		    serviceStatusIterator (nil);
		    continue ;
		}
		UI::BusyCursor ();
	    }
	    else
	    {
		ret = UI::UserInput ();
	    }
	    // we may read this anyway...
	    Runlevel::default = UI::QueryWidget (`id (`default), `Value);
	    if (`back == ret || `abort == ret)
	    {
		if (!reallyAbort ())
		{
		    continue;
		}
	    }
	    else if (`next == ret)
	    {
		if (Runlevel::isDirty ())
		{
		    if (!UI::YesNoPopup (_("Changes made to the runlevels \nwill now be saved.")))
		    {
			continue;
		    }
		}
	    }
	    break;
	}
	return ret;
    }

    /**
     * Returns textual runlevel description. Descriptions are hard-coded in ycp script.
     * @param rl Runlevel to check.
     * @return string Description.
     */
    global define string getRunlevelDescr (string rl) ``{
	return lookup ($[
	    // descriptions of runlevels. there must be number: description
	    // number is runlevel name
	    "0" : _("0: System halt"),
	    "1" : _("1: Single user mode"),
	    "2" : _("2: Local multiuser without remote network"),
	    "3" : _("3: Full multiuser with network"),
	    "4" : _("4: User defined"),
	    "5" : _("5: Full multiuser with network and xdm"),
	    "6" : _("6: System reboot"),
	    ], rl, rl);
    }

    /**
     * Returns items for default runlevel combo box.
     * (Excludes 0, 6, S and B)
     * @return list List of items. Default is selected.
     */
    global define list getDefaultPicker () ``{
	list items = [];
	foreach (`i, Runlevel::runlevels, ``{
	    if ("0" != i && "6" != i && "S" != i && "B" != i)
	    {
		items = add (items, `item (`id (i), getRunlevelDescr (i), i == Runlevel::default));
	    }
	});
	return items;
    }

    /**
     * Disable the service. Changes global services.
     * @param service_name name of the service.
     */
    global define void setServiceDisable (string service_name) ``{
	map service = lookup (Runlevel::services, service_name, $[]);
	Runlevel::services = add (Runlevel::services, service_name,
			union (service,
			       $[
				   "start": [],
				   "dirty": true,
				   ]));
    }
    /**
     * Set service to its default state upon installation.
     * Changes global services.
     * @param service_name Name of service to process.
     */
    global define void setServiceToDefault (string service_name) ``{
	map service = lookup (Runlevel::services, service_name, $[]);
	Runlevel::services = add (Runlevel::services, service_name,
			union (service,
			       $[
				   "start": lookup (service, "defstart", []),
				   "dirty": true,
				   ]));
    }

    /**
     * Starts/stops/checks status of a service
     * @param service_name service to start/stop
     * @param service @ref service other service info
     * @param command "start" or "stop" or "status"
     * @return @ref service updated status
     */
    global define map startStopService (string service_name, string command) ``{
	map out = Runlevel::RunInitScriptOutput (service_name, command);
	string message = "";
	integer exit = lookup (out, "exit", -1);
	if (0 == exit)
	{
	    // show the command output
	    message = sformat (_("Output from '/etc/init.d/%1 %2':\n\n"),
			       service_name, command)
		+ lookup (out, "stdout", "");
	}
	else
	{
	    // show the exit code
	    message = sformat (_("'/etc/init.d/%1 %2' returned %3:\n%4"),
			       service_name, command,
			       exit,
			       (command == "status" ?
				getStatusReturnHelp (exit) :
				getActionReturnHelp (exit))
		);
	}
	// succesful stop => status: program not running
	// TODO: broken scripts may violate this
	exit = command == "stop" ? 3 : 0;
	// normally "started" has the exit code of "status",
	// and we may be adding output of a different command
	// but is is only tested angainst zero anyway
	service = add (service, "started", exit);
	updateStatusColumn (service_name, service["started"]:-1);
	UI::MessagePopup (message);
	return service;
    }

    /**
     * Prints list items into a string, separating them by commas
     * and when line exceeds len characters, it does line break (\n).
     * It adds 5 spaces before each line.
     * Do not expect reasonable results if you set len < 0.
     * @param l list of strings
     * @param len minimal length of line
     * @return string formated string
     */
    global define string formatLine (list l, integer len) ``{
	string s = "";
	string line = "     ";
	string add_sep = "";
	string line_sep = "";
	foreach (`i, l, ``{
	    if (size (line) > len)
		{
		    s = s + line_sep + line;
		    line_sep = ",\n";
		    line = "     ";
		}
	    else
		{
		    line = line + add_sep;
		}
	    line = line + i;
	    add_sep = ", ";
	});
	if (size (line) > 0)
	    {
		s = s + line_sep + line;
	    }
	return s;
    }

    /**
     * Checks what services should run in this runlevel and do not run
     * or what services run but should not run.
     * @return string overview text
     */
    global define string overviewText () ``{
	list should_not_run = [];
	list should_run = [];
	foreach (`k, `v, Runlevel::services, ``{
	    if (contains (v["start"]:[], Runlevel::current))
		{   // it should run
		    if (0 != lookup (v, "started", ""))
			{
			    should_run = add (should_run, k);
			}
		}
	    else
		{
		    if (0 == lookup (v, "started", ""))
			{
			    should_not_run = add (should_not_run, k);
			}
		}
	});
	string s = "";
	if (size (should_run) + size (should_not_run) > 0)
	    {
		// message label
		s = s + "\n\n"/* + _("Overview") + "\n\n"*/;
		if (size (should_not_run) > 0)
		    {
			// list of services will follow
			s = s + _("Following services run in current\nrunlevel although they should not:");
			s = s + "\n" + formatLine (should_not_run, 35) + "\n\n";
		    }

		if (size (should_run) > 0)
		    {
			// list of services will follow
			s = s + _("Following services do not run in current\nrunlevel although they should:");
			s = s + "\n" + formatLine (should_run, 35) + "\n\n";
		    }
	    }
	return s;
    }

    /**
     * Main dialog for changing services.
     * @return symbol for wizard sequencer
     */
    global define symbol allInOne () ``{
	// currently selected service we are working with
	map service = $[];

	/**
	 * Local function to allInOne.
	 * Changes values of runlevel checkboxes.
	 * Get the status if not known yet.
	 */
	define void changeService1 () ``{
	    if (lookup (service, "started", -1) < 0)
	    {
		integer started = Runlevel::RunInitScript (current_service,
							   "status");
		service = add (service, "started", started);
		Runlevel::services = add (Runlevel::services, current_service, service);
		updateStatusColumn (current_service, started);
	    }
	    updateRlCheckBoxes (service);
	}

	/**
	 * Helper function for fetching service status in run-time.
	 * @param service_name which line
	 * @param service @ref service
	 * @param started status or -1 (unknown yet)
	 */
	define void updateStatusInTable (string service_name, map service,
					 integer started) ``{
	    // just translate the arguments. the callback is generic
	    // because of the future simple UI, bug #13789
	    updateStatusColumn (service_name, started);
	}

	// --- body of allInOne ---

	// headers in table
	term header = `header (_("Service"), _("Running"));
	foreach (`i, Runlevel::runlevels, ``{
//	    header = add (header, `Center (" " + i + " "));
	    header = add (header, `Center (i));
	});
	// headers in table
	header = add (header, _("Description"));
	term contents = `VBox (
	    `VSpacing (0.5),
	    `HBox (
		// preserve 2 spaces at the end.
		`Label (_("Current runlevel:  ")),
		`Label (`opt (`outputField, `hstretch), getRunlevelDescr (Runlevel::current))
		),
	    `VSpacing (0.5),
	    `Table (`id (`table), `opt (`notify, `immediate),
		    header,
		    servicesToTable ()
		),
	    `VBox (
		// label above checkboxed
		`Label (`id (`service_label), `opt (`hstretch), _("Service will be started in following runlevels:")),
		getRlCheckBoxes ()
		),
	    `HBox (
		// menubutton label
		`MenuButton (_("S&tart/Stop/Refresh"), [
		    `item (`id (`start), _("&Start now ...")),
		    `item (`id (`stop), _("S&top now ...")),
		    `item (`id (`status), _("&Refresh status ...")),
		    ]),
		`HStretch (),
		`ReplacePoint (
		    `id (`menubutton),
		    // menubutton label
		    `MenuButton (_("Set/&Reset"), [
			`item (`id (`to_enable), _("&Enable the service")),
			`item (`id (`to_disable), _("&Disable the service")),
			`item (`id (`to_all_enable), _("Enable &all services")),
			])
		    )
		)
	    );
	// dialog caption.
	Wizard::SetContents (_("Runlevel editor: details"), contents, getHelpComplex (), true, true);
	UI::ChangeWidget (`id (`table), `CurrentItem, current_service);
	service = lookup (Runlevel::services, current_service, $[]);
	changeService1 ();
	any ret = nil;
	while (`next != ret && `back != ret && `abort != ret)
	    {
		if (fetching_service_status)
		{
		    ret = UI::PollInput ();
		    UI::NormalCursor ();
		    if (nil == ret)
		    {
			serviceStatusIterator (``(updateStatusInTable ()));
			continue;
		    }
		    UI::BusyCursor ();
		}
		else
		{
		    ret = UI::UserInput ();
		}

		if (`abort == ret)
		{
		    if (!reallyAbort ())
			{
			    ret = nil;
			    continue;
			}
		}
		else if (`next == ret)
		{
		    if (Runlevel::CheckXInetd () && !UI::YesNoHeadlinePopup (
				_("Both inetd and xinetd are selected!"),
				_("Services inetd and xinetd need extra configuration
to run simultaneously. Do you really want to run
both of them?")))
		    {
			ret = nil;
			continue;
		    }

		    // TODO: genenric dependency checking
		    string nfs_adj = Runlevel::CheckPortmap ();
		    if (nil != nfs_adj)
		    {
			UI::ChangeWidget (`id (`table), `CurrentItem, "portmap");
			current_service = "portmap";
			service = lookup (Runlevel::services, "portmap", $[]);
			changeService1 ();
			// qt and curses behave differently:
			// one of them sends notification after changewidget
			// and the other does not.
			// So eat it.
			while (nil != UI::PollInput ()) {}
			if (!UI::YesNoPopup (sformat (_("Service portmap, which is required by
%1 is disabled. You should enable
portmap if you want to run %1.

Do you really want to leave portmap
disabled?
"), nfs_adj)))
			{
			    ret = nil;
			    continue;
			}
		    }
		    if (Runlevel::isDirty ())
		    {
			if (!UI::YesNoPopup (_("Now the changes to runlevels \nwill be saved.")))
			{
			    ret = nil;
			    continue;
			}
		    }
		    break;
		}
		else if (`table == ret)
		{
		    current_service = UI::QueryWidget (`id (`table), `CurrentItem);
		    service = Runlevel::services[current_service]:$[];
		    changeService1 ();
		}
		else if (`to_disable == ret)
		{
		    current_service = UI::QueryWidget (`id (`table), `CurrentItem);
		    setServiceDisable (current_service);
		    service = Runlevel::services[current_service]:$[];
		    changeService1 ();
		    updateRlColumns (current_service);
		}
		else if (`to_enable == ret)
		{
		    current_service = UI::QueryWidget (`id (`table), `CurrentItem);
		    setServiceToDefault (current_service);
		    service = Runlevel::services[current_service]:$[];
		    changeService1 ();
		    updateRlColumns (current_service);
		}
		else if (`to_all_enable == ret)
		{
		    if (UI::YesNoPopup (_("Do you really want to enable all services?")))
		    {
			foreach (`k, `v, Runlevel::services, ``{
			    setServiceToDefault (k);
			});
			UI::ChangeWidget (`id (`table), `Items, servicesToTable ());
			UI::MessagePopup (_("All services restored to their original\nstatus upon initial installation."));
		    }
		}
		else if (`start == ret || `stop == ret)
		{
		    boolean really = true;
		    if (`stop == ret && "xdm" == current_service)
		    {
			if (!UI::YesNoPopup ( _("This may kill your X session.\n\nProceed?")))
			{
			    really = false;
			}
		    }
		    if (really)
		    {
			string command = ""+ ret; // drops `
			service = startStopService (current_service, service,
						    command);
		    }
		}
		else if (`status == ret)
		{
		    // similar to startStopService but there will be changes
		    // when dependencies are checked

		    //TODO: find a place for it
		    //UI::MessagePopup (overviewText ());
		    service = startStopService (current_service, service,
						"status");
		}
		else if (nil != ret && is (ret, string))
		{
		    // checkbox pressed
		    // checked of unchecked?
		    string checked = ((UI::QueryWidget (`id (ret), `Value)) ? ret : " ");
		    service = queryRlCheckBoxes (current_service, service);
		    UI::ChangeWidget (`id (`table), `Item (current_service, lookup (runlevel2tableindex, ret, 0)), checked);
		}
	    }
	return ret;
    }
    /**
     * Add service by hand.
     * @return new service name (already added to Runlevel::Services) or ""
     */
    global define string addService () ``{
	UI::OpenDialog (`VBox (
		    `Heading (`opt (`hstretch), _("Add service")),
		    `VSpacing (1),
		    `TextEntry (`id (`name), _("Service &name")),
		    `Label (`opt (`hstretch), _("Starts in these runlevels by default:")),
		    getRlCheckBoxes (),
		    `VSpacing (1),
		    `TextEntry (`id (`des), _("&Description (optional)"), ""),
		    `VSpacing (1),
		    `HBox (`PushButton (`id (`ok), UI::OKButtonLabel ()), `PushButton (`id (`cancel), UI::CancelButtonLabel ()))
		    ));
	symbol ret = nil; // TODO any (symbol|string)
	string name = "";
	boolean r = false;
	while (true)
	{
	    ret = UI::UserInput ();
	    if (`ok == ret)
	    {
		name = UI::QueryWidget (`id (`name), `Value);
		if (nil == name || "" == name || haskey (Runlevel::services, name))
		{
		    UI::MessagePopup (_("Invalid service name. You did not specify service
name or the name specified is already in use."));
		    continue;
		}
		list def = [];
		foreach (`i, Runlevel::runlevels, ``{
		    if (UI::QueryWidget (`id (i), `Value))
		    {
			def = add (def, i);
		    }
		});
		map m = $[
		    "dirty" : true,
		    "defstart" : def,
		    "start" : def,
		    "description" : UI::QueryWidget (`id (`des), `Value)
		    ];
		Runlevel::services = add (Runlevel::services, name, m);
		break;
	    }
	    if (`cancel == ret)
	    {
		name = "";
		break;
	    }
	}
	UI::CloseDialog ();
	return name;
    }
    /**
     * Main dialog for changing services.
     * @return symbol for wizard sequencer
     */
    global define symbol runAutoDialog () ``{
	// currently selected service we are working with
	map service = $[];

	string CheckMark = UI::Glyph (`CheckMark);
	/**
	 * Create table items from services.
	 * @return list List of items for table.
	 */
	define list servicesToTable2 () ``{
	    list items = [];
	    boolean first = true;
	    foreach (`k, `v, Runlevel::services, ``{
		if (first)
		{
		    first = false;
		    current_service = k;
		}
		term item = `item (`id (k), k);

		item = add (item, v["dirty"]:false ? CheckMark : " ");
		list rl = lookup (v, "start", []);
		foreach (`i, Runlevel::runlevels, ``{
		    item = add (item, (contains (rl, i)? i : " "));
		});
		item = add (item, lookup (v, "description", ""));
		items = add (items, item);
	    });
	    return items;
	}

	/**
	 * Sets columns 0-S (runlevels) in table so they are synchronized with checkboxes.
	 */
	define void refreshTableLine2 () ``{
	    updateRlColumns (current_service, service);
	    UI::ChangeWidget (`id (`table), `Item (current_service, 1),
			      service["dirty"]:false ? CheckMark : " ");
	}

	// headers in table
	term header = `header (_("Service"), _("Changed"));
	foreach (`i, Runlevel::runlevels, ``{
//	    header = add (header, `Center (" " + i + " "));
	    header = add (header, `Center (i));
	});
	// headers in table
	header = add (header, _("Description"));
	term contents = `VBox (
	    `VSpacing (0.5),
	    `Table (`id (`table), `opt (`notify, `immediate),
		    header,
		    servicesToTable2 ()
		),
	    `VBox (
		// label above checkboxed
		`Label (`id (`service_label), `opt (`hstretch), _("Service will be started in following runlevels:")),
		getRlCheckBoxes ()
		),
	    `HBox (
		`PushButton (`id (`add), _("A&dd")),
		`HStretch (),
		`PushButton (`id (`clear), _("&Clear")),
		`PushButton (`id (`clear_all), _("Clea&r All")),
		`PushButton (`id (`default), _("D&efault"))
		)
	    );
	// dialog caption.
	Wizard::SetContents (_("Runlevel editor: details"), contents, getHelpAuto (), true, true);
	UI::ChangeWidget (`id (`table), `CurrentItem, current_service);
	service = lookup (Runlevel::services, current_service, $[]);
	updateRlCheckBoxes (service);
	any ret = nil;
	while (nil != UI::PollInput ()) {}
	while (`next != ret && `back != ret && `abort != ret)
	    {
		ret = UI::UserInput ();
		if (`abort == ret)
		{
		    if (!reallyAbort ())
			{
			    ret = nil;
			    continue;
			}
		}
		else if (`next == ret)
		{
		    if (Runlevel::CheckXInetd () && !UI::YesNoHeadlinePopup (
				_("Both inetd and xinetd are selected!"),
				_("Services inetd and xinetd need extra configuration
to run simultaneously. Do you really want to run
both of them?")))
		    {
			ret = nil;
			continue;
		    }
		    string nfs_adj = Runlevel::CheckPortmap ();
		    if (nil != nfs_adj)
		    {
			UI::ChangeWidget (`id (`table), `CurrentItem, "portmap");
			current_service = "portmap";
			service = lookup (Runlevel::services, "portmap", $[]);
			updateRlCheckBoxes (service);
			while (nil != UI::PollInput ()) {}
			if (!UI::YesNoPopup (sformat (_("Service portmap, which is required by
%1 is disabled. You should enable
portmap if you want to run %1.

Do you really want to leave portmap
disabled?
"), nfs_adj)))
			{
			    ret = nil;
			    continue;
			}
		    }
		    break;
		}
		else if (`add == ret)
		{
		    string name = addService ();
		    if ("" != name)
		    {
			UI::ChangeWidget (`id (`table), `Items, servicesToTable2 ());
			UI::ChangeWidget (`id (`table), `CurrentItem, name);
			while (nil != UI::PollInput ()) {}
			ret = `table;
		    }
		}
		else if (`default == ret)
		{
		    setServiceToDefault (current_service);
		    service = Runlevel::services[current_service]:$[];
		    refreshTableLine2 ();
		    ret = `table;
		}
		else if (`clear == ret)
		{
		    // re-read from SCR
		    service = Runlevel::ServiceInfo (current_service);
		    Runlevel::services = add (Runlevel::services, current_service, service);
		    refreshTableLine2 ();
		    ret = `table;
		}
		else if (`clear_all == ret)
		{
		    Runlevel::ClearServices ();
		    UI::ChangeWidget (`id (`table), `Items, servicesToTable2 ());
		    ret = `table;
		}
		else if (nil != ret && is (ret, string))
		{
		    // checkbox pressed
		    // checked or unchecked?
		    string checked = ((UI::QueryWidget (`id (ret), `Value)) ? ret : " ");
		    service = queryRlCheckBoxes (current_service, service);
		    UI::ChangeWidget (`id (`table), `Item (current_service, lookup (runlevel2tableindex, ret, 0)), checked);
		    UI::ChangeWidget (`id (`table), `Item (current_service, 1), CheckMark);
		}

		// not a part of the else-if chain above!
		if (`table == ret)
		{
		    current_service = UI::QueryWidget (`id (`table), `CurrentItem);
		    service = lookup (Runlevel::services, current_service, $[]);
		    updateRlCheckBoxes (service);
		    while (nil != UI::PollInput ()) {}
		}
	    }
	return ret;
    }
}
